% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singleIterationFunctions.R
\name{placeRoads}
\alias{placeRoads}
\title{Place roads for surface impacts}
\usage{
placeRoads(padsIn, simList, totalRoadLength, roadWidth = NULL,
  cellProportion = NULL)
}
\arguments{
\item{padsIn}{List returned from call to \code{\link{placePads}}}

\item{simList}{List returned from \code{\link{prepareSimDistributions}}.}

\item{totalRoadLength}{The total length of road to distribute on the landscape. Direct
output from \code{\link{makeRoads}} or \code{\link{makeRoadsD}} can be used as an input here.}

\item{roadWidth}{Optional. Number specifying road width. Default is 10 meters.}

\item{cellProportion}{Optional. The proportion of a single surface raster cell that can be
covered by road. Default is 2/3 of the cell area.}
}
\value{
List containing road cells and area to be used in \code{\link{impactsRoads}} or \code{\link{rusle}}
}
\description{
Places roads randomly for a single Monte Carlo iteration.
}
\details{
The functions \code{\link{makeRoads}} and \code{\link{makeRoadsD}} return the total length 
of the required roads. This function will take that total road length and
randomly distribute it across the landscape at a set road width for comparison to any
surface raster. Road segments are randomly distributed and there is no connectivity or
continuity implied. If optional parameters are omitted, roads may cover a maximum of 2/3
of the area of a single surface cell at specified resolution.
}
\note{
Edited by CDMartinez  27 Feb 17
}
\examples{
library(raster)
set.seed(46)
OGasmt <- continuousAssessment(auMC = 5,
auType = 'Gas',
auProbability = 1,
auAreaProductive = c(100,400,800),
auAreaDrainage = c(10,20,40),
auPercAreaUntested = c(93,96,99),
auPercAreaSweet = c(100,100,100),
auPercFutureSS = c(20,40,50),
auEURss = c(0.15,0.4,0.65),
auLGR = c(.08,.5,1),
year = 2016)

OGasmt <- convertAcre2sqMeter(OGasmt)

rBase <- raster(resolution = c(10,10), xmn = 0, xmx = 2000, ymn = 0, ymx = 2000)
values(rBase) <- sample(1:10, 40000, replace = TRUE)

points <- rbind(c(250,250),c(250,1750),c(1750,1750),c(1750,250),c(250,250))
shape <- SpatialPolygons(list(Polygons(list(Polygon(points)), 'auOutline')))

plot(rBase, xlim = c(0,2000), ylim = c(0,2000))
lines(shape)

spatialPrep <- prepareSimSpatial(surfaceRaster = rBase, shape, OGasmt)
distributionPrep <- prepareSimDistributions(spatialPrep,wellsPerPad = 3,
padArea = 500, EA = OGasmt, numIterations=5)

# Create road network
nVertices <- 500
road1 <- cbind(seq(0, 2000, length.out = nVertices),
seq(0, 100, length.out = nVertices)*sin(seq(-pi, 1.5*pi, length.out = nVertices)) + 600)
road2 <- cbind(200*cos(seq(-pi, 1.5*pi, length.out = nVertices)) +
seq(200, 1800, length.out = nVertices), seq(0, 2000, length.out = nVertices))
# Prepare road input: a two-column matrix of (Easting, Northing)
prepRoads <- rbind(road1, road2, cbind(road1[,1],rev(road1[,2]) + 700))

pads <- placePads(distributionPrep, 5)
roadLength <- makeRoads(xyStarts = pads$xyPadCenter, roadNodes = prepRoads)
roads <- placeRoads(padsIn = pads, simList = distributionPrep, totalRoadLength = roadLength)

}
\author{
Created by CDMartinez 27 Feb 17
}
